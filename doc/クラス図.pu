@startuml クラス図

' 設定
hide empty members

skinparam class {
  BackgroundColor<<SubStep>> LightSkyBlue
  BackgroundColor<<Dependency>> LightGreen
  BackgroundColor<<ValueObject>> DarkSalmon
  BackgroundColor<<Entity>> LightSalmon
  BackgroundColor<<Aggregate>> Salmon
  BackgroundColor<<Event>> Plum
  BackgroundColor<<Error>> OrangeRed
  BackgroundColor<<Command>> Turquoise
  BackgroundColor<<Shared>> Lime
  BackgroundColor<<WorkFlow>> Yellow
}

' 外部ライブラリ
package Fsharp {
  class Async<Result<success, failure>> {}
}
' * 今回は未使用
' package Fsharpx.Collections {}

' 共通
interface Undefined.Undefined <<exn>> {}

' 型の定義
package Domain {
  class ValueObject.UserID <<ValueObject>> extends Undefined.Undefined {}

  package Shared {
    class AsyncResult<success, failure> <<Shared>> extends Microsoft.Fsharp.Async {}
    class Command<data> <<Shared>> {
      + Data: data
      + Timestamp: System.DateTime
      + UserID: UserID
      ' TODO etc...
    }
    Domain.ValueObject.UserID <-- Domain.Shared.Command
  }

  package ValueObject {
    class WidgetCode <<ValueObject>> {
      + WidgetCode: string
    }
    class GizmoCode <<ValueObject>> {
      + GizmoCode: string
    }

    enum ProductCode <<ValueObject>> {
      + Widget of WidgetCode
      + Gizmo of GizmoCode
    }
    Domain.ValueObject.WidgetCode <-- Domain.ValueObject.ProductCode
    Domain.ValueObject.GizmoCode <-- Domain.ValueObject.ProductCode

    class UnitQuantity <<ValueObject>> {
      - UnitQuantity: int
      + create(qty: int): Result<UnitQuantity, Error>
      + value(qty: UnitQuantity): UnitQuantity
    }
    class KilogramQuantity <<ValueObject>> {
      - KilogramQuantity: decimal<kg>
    }
    FSharp.Data.UnitSystems.SI.UnitSymbols.kg <-- Domain.ValueObject.KilogramQuantity

    enum OrderQuantity <<ValueObject>> {
      + Unit: UnitQuantity
      + Kilos: KilogramQuantity
    }
    Domain.ValueObject.UnitQuantity <-- Domain.ValueObject.OrderQuantity
    Domain.ValueObject.KilogramQuantity <-- Domain.ValueObject.OrderQuantity

    class OrderID <<ValueObject>> {
      - OrderID: string
      + create(str: string): OrderID or failwith ' TODO
      ' これはいらない・定義したくないかも
      + value(OrderID: OrderID): string
    }
    ' 今回のシステムではいらない
    ' class OrderLineID <<ValueObject>> extends Undefined.Undefined {}
    ' class CustomerID <<ValueObject>> extends Undefined.Undefined {}
    class UnValidatedCustomer <<ValueObject>> {
      + Name: string
      + Email: string
    }
    class UnValidatedAddress <<ValueObject>> {
      + UnValidatedAddress: string
    }
    class CustomerInfo <<ValueObject>> extends Undefined.Undefined {}
    class Address <<ValueObject>> {
      + Address: string
    }
    class ValidatedOrderLine <<ValueObject>> extends Undefined.Undefined {}
    class PricedOrderLine <<ValueObject>> extends Undefined.Undefined {}
    class BillingAmount <<ValueObject>> extends Undefined.Undefined {}

    class CheckedAddress <<ValueObject>> extends Undefined.Undefined {}

    class Price <<ValueObject>> extends Undefined.Undefined {}
    class HTMLString <<ValueObject>> {
      + HTMLString: string
    }
    class EmailAddress <<ValueObject>> extends Undefined.Undefined {}

    class OrderAcknowledgment <<ValueObject>> {
      + EmailAddress: EmailAddress
      + Letter: HTMLString
    }
    Domain.ValueObject.EmailAddress <-- Domain.ValueObject.OrderAcknowledgment
    Domain.ValueObject.HTMLString <-- Domain.ValueObject.OrderAcknowledgment

    enum SendResult <<ValueObject>> {
      + Sent: "Sent"
      + NotSent: "NotSent"
    }
  }

  package Entity {
    class UnValidatedOrder <<Entity>> {
      OrderID: string
      CustomerInfo: UnValidatedCustomer
      ShippingAddress: UnValidatedAddress
      ' TODO etc...
    }
    Domain.ValueObject.UnValidatedCustomer <-- Domain.Entity.UnValidatedOrder
    Domain.ValueObject.UnValidatedAddress <-- Domain.Entity.UnValidatedOrder

    class ValidatedOrder <<Entity>> {
      + OrderID: OrderID
      + CustomerInfo: CustomerInfo
      + ShippingAddress: Address
      + BillingAddress: Address
      + OrderLines: ValidatedOrderLine list
    }
    Domain.ValueObject.OrderID <-- Domain.Entity.ValidatedOrder
    Domain.ValueObject.CustomerInfo <-- Domain.Entity.ValidatedOrder
    Domain.ValueObject.Address <-- Domain.Entity.ValidatedOrder
    Domain.ValueObject.ValidatedOrderLine <-- Domain.Entity.ValidatedOrder

    class PricedOrder <<Entity>> {
      OrderID: OrderID
      CustomerInfo: CustomerInfo
      ShippingAddress: Address
      BillingAddress: Address
      OrderLines: PricedOrderLine list
      AmountToBill: BillingAmount
    }
    Domain.ValueObject.OrderID <-- Domain.Entity.PricedOrder
    Domain.ValueObject.CustomerInfo <-- Domain.Entity.PricedOrder
    Domain.ValueObject.Address <-- Domain.Entity.PricedOrder
    Domain.ValueObject.PricedOrderLine <-- Domain.Entity.PricedOrder
    Domain.ValueObject.BillingAmount <-- Domain.Entity.PricedOrder

    enum Order <<Aggregate>> {
      + UnValidated: UnValidatedOrder
      + Validated: ValidatedOrder
      + Priced: PricedOrder
    }
    Domain.Entity.UnValidatedOrder <-- Domain.Entity.Order
    Domain.Entity.ValidatedOrder <-- Domain.Entity.Order
    Domain.Entity.PricedOrder <-- Domain.Entity.Order
  }

  package Errors {
    class ValidationError <<Error>> {
      + FieldName: string
      + ErrorDescription: string
    }

    class AddressValidationError <<Error>> {
      + AddressValidationError: string
    }

    class PricingError <<Error>> {
      + PricingError: string
    }

    ' ワークフロー失敗時の出力（エラー型）
    enum PlaceOrderError <<Error>> {
      + ValidationError: ValidationError list
      ' TODO etc... その他のエラー
    }
    Domain.Errors.ValidationError <-- Domain.Errors.PlaceOrderError
  }

  package Events {
    class OrderAcknowledgmentSent <<Event>> {
      + OrderID: OrderID
      + EmailAddress: EmailAddress
    }
    Domain.ValueObject.OrderID <-- Domain.Events.OrderAcknowledgmentSent
    Domain.ValueObject.EmailAddress <-- Domain.Events.OrderAcknowledgmentSent

    class OrderPlaced <<Event>> extends Domain.Entity.PricedOrder {}
    class BillableOrderPlaced <<Event>> {
      + OrderID: OrderID
      + BillingAddress: Address
      + AmountToBill: BillingAmount
    }
    Domain.ValueObject.OrderID <-- Domain.Events.BillableOrderPlaced
    Domain.ValueObject.Address <-- Domain.Events.BillableOrderPlaced
    Domain.ValueObject.BillingAmount <-- Domain.Events.BillableOrderPlaced

    enum PlaceOrderEvent <<Event>> {
      + OrderPlaced: OrderPlaced
      + BillableOrderPlaced: BillableOrderPlaced
      + AcknowledgmentSent: OrderAcknowledgmentSent
    }
    Domain.Events.OrderPlaced <-- Domain.Events.PlaceOrderEvent
    Domain.Events.BillableOrderPlaced <-- Domain.Events.PlaceOrderEvent
    Domain.Events.OrderAcknowledgmentSent <-- Domain.Events.PlaceOrderEvent
  }

  package Service {
    class CreateOrderAcknowledgmentLetter <<Dependency>> {
      + CreateOrderAcknowledgmentLetter(PricedOrder): HTMLString
    }
    Domain.Entity.PricedOrder <-- Domain.Service.CreateOrderAcknowledgmentLetter
    Domain.ValueObject.HTMLString <-- Domain.Service.CreateOrderAcknowledgmentLetter
  }

  package Interface {
    package Repository {}

    package Provider {
      ' 起動時に読み込み、InMemory上に保管しておき、呼び出されたらそれを用いる
      class CheckProductCodeExists <<Dependency>> {
        + CheckProductCodeExists(ProductCode)\n\t: bool
      }
      Domain.ValueObject.ProductCode <-- Domain.Interface.Provider.CheckProductCodeExists

      class GetProductPrice <<Dependency>> {
        + GetProductPrice(ProductCode): Price
      }
      Domain.ValueObject.ProductCode <-- Domain.Interface.Provider.GetProductPrice
      Domain.ValueObject.Price <-- Domain.Interface.Provider.GetProductPrice
    }

    package Remote {
      class CheckAddressExists <<Dependency>> {
        + CheckAddressExists(UnValidatedAddress)\n\t: AsyncResult<CheckedAddress, AddressValidationError>
      }
      Domain.ValueObject.UnValidatedAddress <-- Domain.Interface.Remote.CheckAddressExists
      Domain.Shared.AsyncResult <-- Domain.Interface.Remote.CheckAddressExists
      Domain.ValueObject.CheckedAddress <-- Domain.Interface.Remote.CheckAddressExists
      Domain.Errors.AddressValidationError <-- Domain.Interface.Remote.CheckAddressExists

      class SendOrderAcknowledgment <<Dependency>> {
        + SendOrderAcknowledgment(OrderAcknowledgment)\n\t: Async<SendResult>
      }
      Domain.ValueObject.OrderAcknowledgment <-- Domain.Interface.Remote.SendOrderAcknowledgment
      Domain.ValueObject.SendResult <-- Domain.Interface.Remote.SendOrderAcknowledgment
    }
  }
}

package Infrastructure {
  package Provider {}
  Domain.Interface.Provider <|.. Infrastructure.Provider

  package Remote {}
  Domain.Interface.Remote <|.. Infrastructure.Remote

  package Repository {}
  Domain.Interface.Repository <|.. Infrastructure.Repository
}

package Usecases {
  package Commands {
    ' ワークフローの入力（コマンド）
    class PlaceOrderCommand <<Command>> extends Domain.Shared.Command {
      <data = UnValidatedOrder>
    }
    Domain.Entity.UnValidatedOrder <-- Usecases.Commands.PlaceOrderCommand

    enum OrderTakingCommand <<Command>> {
      + Place: PlaceOrderCommand
      ' + Change: ChangeOrder
      ' + Cancel: CancelOrder
    }
    Usecases.Commands.PlaceOrderCommand <-- Usecases.Commands.OrderTakingCommand
  }

  package Workflows {
    ' サブステップ：検証
    class ValidateOrder <<SubStep>> {
      + ValidateOrder(\n\t CheckProductCodeExists,\n\t CheckAddressExists,\n\t UnValidatedOrder,\n ): AsyncResult<ValidatedOrder, ValidationError list>
    }
    Domain.Interface.Provider.CheckProductCodeExists <-- Usecases.Workflows.ValidateOrder
    Domain.Interface.Remote.CheckAddressExists <-- Usecases.Workflows.ValidateOrder
    Domain.Entity.UnValidatedOrder <-- Usecases.Workflows.ValidateOrder
    Domain.Shared.AsyncResult <-- Usecases.Workflows.ValidateOrder
    Domain.Entity.ValidatedOrder <-- Usecases.Workflows.ValidateOrder
    Domain.Errors.ValidationError <-- Usecases.Workflows.ValidateOrder

    ' サブステップ：価格計算
    class PriceOrder <<SubStep>> {
      + PriceOrder(\n\t GetProductPrice,\n\t ValidatedOrder,\n ): Result<PricedOrder, PricingError>
    }
    Domain.Interface.Provider.GetProductPrice <-- Usecases.Workflows.PriceOrder
    Domain.Entity.ValidatedOrder <-- Usecases.Workflows.PriceOrder
    Domain.Entity.PricedOrder <-- Usecases.Workflows.PriceOrder
    Domain.Errors.PricingError <-- Usecases.Workflows.PriceOrder

    ' サブステップ：注文確認
    class AcknowledgeOrder <<SubStep>> {
      + AcknowledgeOrder(\n\t CreateOrderAcknowledgmentLetter,\n\t SendOrderAcknowledgment,\n\t PricedOrder,\n ): Async<OrderAcknowledgmentSent option>
    }
    Domain.Service.CreateOrderAcknowledgmentLetter <-- Usecases.Workflows.AcknowledgeOrder
    Domain.Interface.Remote.SendOrderAcknowledgment <-- Usecases.Workflows.AcknowledgeOrder
    PricedOrder <-- Usecases.Workflows.AcknowledgeOrder
    Domain.Events.OrderAcknowledgmentSent <-- Usecases.Workflows.AcknowledgeOrder

    ' サブステップ：イベント作成・返却
    class CreateEvents <<SubStep>> {
      + CreateEvents(PricedOrder): PlaceOrderEvent list
    }
    Domain.Entity.PricedOrder <-- Usecases.Workflows.CreateEvents
    Domain.Events.PlaceOrderEvent <-- Usecases.Workflows.CreateEvents

    ' 注文確定のワークフロー：「注文確定」プロセス
    class PlaceOrderWorkflow <<WorkFlow>> {
      + PlaceOrderWorkflow(PlaceOrderCommand)\n\t: AsyncResult<PlaceOrderEvent list, PlaceOrderError>
    }
    Usecases.Commands.PlaceOrderCommand <-- Usecases.Workflows.PlaceOrderWorkflow
    Domain.Shared.AsyncResult <-- Usecases.Workflows.PlaceOrderWorkflow
    Domain.Events.PlaceOrderEvent <-- Usecases.Workflows.PlaceOrderWorkflow
    Domain.Errors.PlaceOrderError <-- Usecases.Workflows.PlaceOrderWorkflow
  }
}

@enduml
